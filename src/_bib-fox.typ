#let _numbering = numbering
#let _const-func = x => x;
#let _missing = ()=>{};

/// Initialize a custom bib / reference counting system.
/// This can be used when you don't want to directly use Typst's `bibliography` function in order to have more precise control over the style and format of your bib / reference list.
///
/// ```example
/// #let ref = ref-init()
///
/// = Example
/// The quick@id2 brown fox@id3 jumps@id1 over the lazy@id4 dog.
///
/// == references
/// #context [
///   #set par(spacing: par.leading)
///   #set grid(
///     row-gutter: par.leading,
///     column-gutter: 1em,
///   )
///   - from site 1
///     #grid(
///       columns: 3,
///       ref("id1"),
///       [Lorem Ipsum], [by Joe Doe],
///       ref("id2"),
///       [Dolor Sit Amet], [by Foo],
///     )
///   - from site 2
///     #grid(
///       columns: 3,
///       ref("id3"),
///       [Lorem Ipsum], [by Joe Doe],
///       ref("id4"),
///       [Dolor Sit Amet], [by Bar],
///     )
/// ]
/// ```
///
/// -> array
#let bib-init(
  /// reference numbering style
  /// -> function | str
  numbering: "[1]",
  /// A function that post-processes the generated numbering content when a new reference is created.
  /// -> function | none
  new-ref-wrapper: none,
  /// A function that post-processes the generated numbering content when an existing reference is used. The default behavior is to superscript the reference numbering.
  /// -> function | none
  use-ref-wrapper: none,
) = {
  if new-ref-wrapper == none {
    new-ref-wrapper = _const-func
  }
  if use-ref-wrapper == none {
    use-ref-wrapper = _const-func
  }
  let ref-counter = counter("ref")
  let ref-dict = state("ref-dict", (:))

  /// Create or use a reference.
  let bib(
    /// The reference key. When a string is passed a new reference is created with a label of the string's content. When a label is passed it uses the created reference.
    /// -> str | label
    key,
    /// The behavior to update the counter when a new reference is created.
    /// -> int | array | function
    update: i => i + 1,
  ) = {
    // create a new reference key
    ref-counter.update(update)
    ref-dict.update(data => {
      data.insert(key, true)
      data
    })
    [#context new-ref-wrapper(_numbering(numbering, ..ref-counter.get())) #label(key)]
  }

  let bib-show(it) = {
    let lbl = it.target
    let key = str(lbl)
    if key in ref-dict.final() {
      link(lbl, use-ref-wrapper(context _numbering(numbering, ..ref-counter.at(lbl))))
    } else {
      it
    }
  }

  (bib, bib-show)
}

/// Present bibliography / references in the form of a list
#let bib-list(
  /// the `bib` function generated by `bib-init`
  /// -> function
  bib,
  /// reference items
  /// -> array
  ..items,
  /// the order that fields in reference items are presented
  /// -> array
  fields: (1,),
  /// Conversion functions that maps a field value to formatted content. If a parser function is not specified for a field, the original value will be used.
  /// -> dict | array
  field-parsers: (:),
  /// Whether the parser should skip field values that are already of type `content`.
  /// -> bool
  parser-skip-content: true,
  parser-arg-item: false,
  number-space: 0.5em,
  field-space: 1em,
) = {
  let grid-cells = ();
  let cell
  for item in items.pos() {
    if type(item) == dictionary {
      assert("key" in item, message: "A reference key must be specified")
      grid-cells.push(bib(item.key))
    } else {
      grid-cells.push(bib(item.at(0)))
    }
    for field in fields {
      let value = item.at(field, default: _missing);
      if value == _missing {
        cell = []
      } else if type(value) == content and parser-skip-content {
        cell = value
      } else {
        let parser = field-parsers.at(field, default: none)
        if parser == none {
          cell = value
        } else if parser-arg-item {
          cell = parser(item)
        } else {
          cell = parser(value)
        }
      }
      grid-cells.push(cell)
    }
  }
  context grid(
    row-gutter: par.leading,
    column-gutter: (number-space,) + (field-space,) * fields.len(),
    columns: fields.len() + 1,
    ..grid-cells,
  )
}